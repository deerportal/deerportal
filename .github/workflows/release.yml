name: Release

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags like v0.9.0, v1.0.0, etc.
  workflow_dispatch:  # Allow manual triggering
    inputs:
      version:
        description: 'Version to build (e.g., 0.9.0)'
        required: true
        default: '0.9.0'
      test_mode:
        description: 'Test mode (builds packages but skips GitHub release creation)'
        type: boolean
        default: false

permissions:
  contents: write
  actions: read
  packages: write

env:
  BUILD_TYPE: Release

jobs:
  # Create GitHub Release First (Scout Job)
  create-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.VERSION }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Get version from tag or input
      id: get_version
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION=${GITHUB_REF#refs/tags/v}
        fi
        echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
        echo "Creating release for version: ${VERSION}"
        
    - name: Create GitHub Release
      if: github.event_name == 'push' && !inputs.test_mode
      id: create_release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ github.ref }}
        name: DeerPortal v${{ steps.get_version.outputs.VERSION }}
        draft: false
        prerelease: false
        body: |
          ## DeerPortal v${{ steps.get_version.outputs.VERSION }}
          
          ### Installation Instructions
          
          #### macOS
          1. Download `DeerPortal-${{ steps.get_version.outputs.VERSION }}-macOS.dmg`
          2. Open the DMG file
          3. Drag DeerPortal.app to Applications folder
          4. Launch from Applications
          
          #### Windows
          1. Download `DeerPortal-${{ steps.get_version.outputs.VERSION }}-Windows.exe`
          2. Run the installer
          3. Follow installation wizard
          4. Launch from Start Menu
          
          #### Linux
          1. Download `DeerPortal-${{ steps.get_version.outputs.VERSION }}-Linux.deb` (Debian/Ubuntu)
          2. Install with: `sudo dpkg -i DeerPortal-*.deb`
          3. Or download `DeerPortal-${{ steps.get_version.outputs.VERSION }}-Linux.tar.gz` (Universal)
          4. Launch with: `./DeerPortal`
          
          #### Game Documentation
          📖 **Game Handbook**: Download `DeerPortal-Handbook-${{ steps.get_version.outputs.VERSION }}.pdf` for complete game rules, card reference, and strategic gameplay guide.
          
          ### System Requirements
          - **macOS**: 10.15 (Catalina) or later
          - **Windows**: Windows 10 or later
          - **Linux**: Ubuntu 18.04+ or equivalent
          - **RAM**: 4GB recommended
          - **Graphics**: OpenGL 3.3 support
          
          ### Controls
          - Mouse: Navigate menus and select moves
          - Escape: Exit game
          - Space: Various game actions
          
          Enjoy your journey to becoming a deer! 🦌

  # Generate PDF Handbook (Documentation Job)
  generate-handbook-pdf:
    runs-on: ubuntu-latest
    needs: create-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Install LaTeX and Pandoc
      run: |
        sudo apt-get update
        sudo apt-get install -y texlive-latex-extra texlive-fonts-recommended pandoc
        
    - name: Generate PDF from Markdown
      run: |
        # Convert HANDBOOK.md to PDF using pandoc
        pandoc HANDBOOK.md \
          -o "DeerPortal-Handbook-${{ needs.create-release.outputs.version }}.pdf" \
          --pdf-engine=pdflatex \
          --variable=geometry:margin=1in \
          --variable=fontsize:12pt \
          --variable=documentclass:article \
          --table-of-contents \
          --highlight-style=tango
        
        echo "=== Generated PDF ==="
        ls -lh DeerPortal-Handbook-*.pdf
        
    - name: Upload PDF artifact
      uses: actions/upload-artifact@v4
      with:
        name: DeerPortal-Handbook-${{ needs.create-release.outputs.version }}
        path: DeerPortal-Handbook-*.pdf
        retention-days: 30
        
    - name: Upload PDF to Release
      if: github.event_name == 'push' && !inputs.test_mode
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: DeerPortal-Handbook-*.pdf
        tag: ${{ github.ref }}
        overwrite: true
        file_glob: true
      continue-on-error: true

  # macOS Build with DMG creation (Warrior Job 1)
  build-macos:
    runs-on: macos-latest
    needs: create-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
      
    - name: Test Mode Notification
      if: inputs.test_mode
      run: |
        echo "🧪 ====================================="
        echo "🧪 TEST MODE ENABLED"
        echo "🧪 This build will create packages but"
        echo "🧪 will NOT create a GitHub release"
        echo "🧪 ====================================="

    - name: Use version from release job
      run: |
        echo "Building version: ${{ needs.create-release.outputs.version }}"

    - name: Update version.txt
      run: |
        echo "${{ needs.create-release.outputs.version }}" > version.txt
        cat version.txt

    - name: Install dependencies
      run: |
        brew update
        brew install cmake

    - name: Install SFML 3.0.1
      run: |
        # Build SFML 3.0.1 from source for macOS
        git clone --depth 1 --branch 3.0.1 https://github.com/SFML/SFML.git sfml-source
        cd sfml-source
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_OSX_DEPLOYMENT_TARGET=10.15 \
          -DSFML_BUILD_EXAMPLES=OFF \
          -DSFML_BUILD_DOC=OFF \
          -DBUILD_SHARED_LIBS=OFF \
          -DCMAKE_INSTALL_PREFIX=/usr/local
        cmake --build build -j$(sysctl -n hw.ncpu) --config Release
        sudo cmake --install build
        cd ..
        rm -rf sfml-source

    - name: Configure CMake
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DCMAKE_OSX_DEPLOYMENT_TARGET=10.15 \
          -DSFML_STATIC_LIBRARIES=ON

    - name: Build
      run: |
        cmake --build build --config ${{ env.BUILD_TYPE }} -j$(sysctl -n hw.ncpu)

    - name: Create DMG package
      run: |
        cd build
        echo "=== Build directory contents ==="
        ls -la
        echo "=== Looking for app bundle ==="
        find . -name "*.app" -type d
        echo "=== Checking Makefile targets ==="
        make help | grep -E "(dmg|package)" || echo "Custom targets not found in help"
        echo "=== Creating DMG package ==="
        make dmg || {
          echo "=== make dmg failed, creating DMG manually ==="
          # Fallback: Create DMG manually using the same approach as in CMakeLists.txt
          VERSION_FROM_FILE=$(cat ../version.txt || echo "0.9.0")
          DMG_NAME="DeerPortal-${VERSION_FROM_FILE}-macOS"
          DMG_TEMP_DIR="dmg_temp"
          
          # Clean and create temp directory
          rm -rf "${DMG_TEMP_DIR}" "${DMG_NAME}".dmg "${DMG_NAME}"-temp.dmg
          mkdir -p "${DMG_TEMP_DIR}"
          
          # Find and copy app bundle
          APP_BUNDLE=$(find . -name "DeerPortal.app" -type d | head -1)
          if [ -n "$APP_BUNDLE" ]; then
            cp -R "$APP_BUNDLE" "${DMG_TEMP_DIR}/"
            codesign --force --deep --sign - "${DMG_TEMP_DIR}/DeerPortal.app" 2>/dev/null || true
            
            # Copy background and create symlink
            cp ../packaging/dmg_background.png "${DMG_TEMP_DIR}/.background.png" 2>/dev/null || true
            ln -s /Applications "${DMG_TEMP_DIR}/Applications"
            
            # Create DMG
            hdiutil create -volname "${DMG_NAME}" -srcfolder "${DMG_TEMP_DIR}" -ov -format UDRW "${DMG_NAME}-temp.dmg"
            hdiutil convert "${DMG_NAME}-temp.dmg" -format UDBZ -o "${DMG_NAME}.dmg"
            
            # Clean up
            rm -rf "${DMG_TEMP_DIR}" "${DMG_NAME}-temp.dmg"
            echo "✅ DMG created manually: ${DMG_NAME}.dmg"
            ls -lh "${DMG_NAME}.dmg"
          else
            echo "❌ No app bundle found for DMG creation"
            exit 1
          fi
        }

    - name: Upload DMG artifact
      uses: actions/upload-artifact@v4
      with:
        name: DeerPortal-${{ needs.create-release.outputs.version }}-macOS-dmg
        path: |
          build/*.dmg
          build/*DeerPortal*
        retention-days: 30

    - name: Check for macOS packages
      id: check_macos_files
      run: |
        cd build
        echo "=== Checking for package files ==="
        DMG_EXISTS="false"
        
        if ls *.dmg 1> /dev/null 2>&1; then
          echo "DMG files found:"
          ls -la *.dmg
          DMG_EXISTS="true"
        else
          echo "No DMG files found"
        fi
        
        echo "dmg_exists=${DMG_EXISTS}" >> $GITHUB_OUTPUT

    - name: Upload DMG to Release
      if: github.event_name == 'push' && !inputs.test_mode && steps.check_macos_files.outputs.dmg_exists == 'true'
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: build/*.dmg
        tag: ${{ github.ref }}
        overwrite: true
        file_glob: true

  # Windows Build
  build-windows:
    runs-on: windows-latest
    needs: create-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Use version from release job
      run: |
        echo "Building version: ${{ needs.create-release.outputs.version }}"

    - name: Update version.txt
      shell: bash
      run: |
        echo "${{ needs.create-release.outputs.version }}" > version.txt
        cat version.txt

    - name: Setup MSVC
      uses: microsoft/setup-msbuild@v1.1

    - name: Install NSIS
      run: |
        choco install nsis -y
        echo "NSIS installed successfully"
        echo "Adding NSIS to PATH"
        echo "C:\Program Files (x86)\NSIS" >> $GITHUB_PATH
        echo "Checking NSIS installation:"
        ls "C:\Program Files (x86)\NSIS" || echo "NSIS not found in default location"

    - name: Install SFML 3.0.1
      shell: bash
      run: |
        # Download and build SFML 3.0.1 for Windows
        git clone --depth 1 --branch 3.0.1 https://github.com/SFML/SFML.git sfml-source
        cd sfml-source
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DSFML_BUILD_EXAMPLES=OFF \
          -DSFML_BUILD_DOC=OFF \
          -DBUILD_SHARED_LIBS=OFF \
          -DCMAKE_INSTALL_PREFIX="C:/SFML"
        cmake --build build --config Release
        cmake --install build
        cd ..
        rm -rf sfml-source

    - name: Configure CMake
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} -DCMAKE_PREFIX_PATH="C:/SFML" -DSFML_DIR="C:/SFML/lib/cmake/SFML"

    - name: Build
      run: |
        cmake --build build --config ${{ env.BUILD_TYPE }}

    - name: Create Windows package
      shell: bash
      run: |
        cd build
        echo "=== Creating Windows package ==="
        echo "Checking if makensis is available:"
        which makensis || echo "makensis not found"
        echo "=== Build directory contents ==="
        ls -la
        echo "=== Looking for DeerPortal executable ==="
        find . -name "DeerPortal*" -type f
        echo "=== Trying make package first ==="
        make package || {
          echo "=== make package failed, trying direct CPack ==="
          cpack -G NSIS --verbose || {
            echo "NSIS packaging failed, trying ZIP fallback"
            cpack -G ZIP --verbose
          }
        }
        echo "=== Files created after packaging ==="
        ls -la *.tar.gz *.deb *.zip *.exe *.dmg 2>/dev/null || echo "No packages found with common extensions"
        echo "=== All files in build directory ==="
        find . -maxdepth 1 -type f -name "*DeerPortal*" -o -name "*.exe" -o -name "*.zip" | sort

    - name: Upload Windows artifact
      uses: actions/upload-artifact@v4
      with:
        name: DeerPortal-${{ needs.create-release.outputs.version }}-Windows-installer
        path: |
          build/*.exe
          build/*.zip
          build/*DeerPortal*
        retention-days: 30

    - name: Check for Windows packages
      id: check_windows_files
      shell: bash
      run: |
        cd build
        echo "=== Checking for package files ==="
        EXE_EXISTS="false"
        ZIP_EXISTS="false"
        
        if ls *.exe 1> /dev/null 2>&1; then
          echo "EXE files found:"
          ls -la *.exe
          EXE_EXISTS="true"
        else
          echo "No EXE files found"
        fi
        
        if ls *.zip 1> /dev/null 2>&1; then
          echo "ZIP files found:"
          ls -la *.zip
          ZIP_EXISTS="true"
        else
          echo "No ZIP files found"
        fi
        
        echo "exe_exists=${EXE_EXISTS}" >> $GITHUB_OUTPUT
        echo "zip_exists=${ZIP_EXISTS}" >> $GITHUB_OUTPUT

    - name: Upload Windows EXE to Release
      if: github.event_name == 'push' && !inputs.test_mode && steps.check_windows_files.outputs.exe_exists == 'true'
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: build/*.exe
        tag: ${{ github.ref }}
        overwrite: true
        file_glob: true

    - name: Upload Windows ZIP to Release
      if: github.event_name == 'push' && !inputs.test_mode && steps.check_windows_files.outputs.zip_exists == 'true'
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: build/*.zip
        tag: ${{ github.ref }}
        overwrite: true
        file_glob: true

  # Linux Build
  build-linux:
    runs-on: ubuntu-latest
    needs: create-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Use version from release job
      run: |
        echo "Building version: ${{ needs.create-release.outputs.version }}"

    - name: Update version.txt
      run: |
        echo "${{ needs.create-release.outputs.version }}" > version.txt
        cat version.txt

    - name: Install dependencies
      run: |
        sudo apt update
        sudo apt install -y \
          build-essential \
          cmake \
          git \
          libfreetype6-dev \
          libopenal-dev \
          libvorbis-dev \
          libflac-dev \
          libudev-dev \
          libgl1-mesa-dev \
          libxrandr-dev \
          libxcursor-dev \
          libxi-dev \
          libx11-dev \
          pkg-config

    - name: Install SFML 3.0.1
      run: |
        git clone --depth 1 --branch 3.0.1 https://github.com/SFML/SFML.git sfml-source
        cd sfml-source
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DSFML_BUILD_EXAMPLES=OFF \
          -DSFML_BUILD_DOC=OFF \
          -DBUILD_SHARED_LIBS=OFF \
          -DCMAKE_INSTALL_PREFIX=/usr/local
        cmake --build build -j$(nproc) --config Release
        sudo cmake --install build
        cd ..
        rm -rf sfml-source

    - name: Configure CMake
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DSFML_STATIC_LIBRARIES=ON

    - name: Build
      run: |
        cmake --build build --config ${{ env.BUILD_TYPE }} -j$(nproc)

    - name: Create Linux packages
      run: |
        cd build
        echo "=== Build directory contents ==="
        ls -la
        echo "=== Looking for DeerPortal executable ==="
        find . -name "DeerPortal" -type f
        echo "=== Fixing permissions ==="
        chmod +x DeerPortal || true
        echo "=== Available package targets ==="
        make help | grep -E "(package|cpack)" || echo "Package targets not found"
        echo "=== Creating packages ==="
        make package || {
          echo "=== make package failed, trying direct CPack ==="
          cpack -G TGZ || echo "TGZ packaging failed"
          cpack -G DEB || echo "DEB packaging failed" 
        }
        echo "=== Files created after packaging ==="
        ls -la *.tar.gz *.deb *.zip *.exe *.dmg 2>/dev/null || echo "No packages found with common extensions"
        echo "=== All files in build directory ==="
        find . -maxdepth 1 -type f -name "*DeerPortal*" -o -name "*.tar.gz" -o -name "*.deb" | sort

    - name: Upload Linux artifacts
      uses: actions/upload-artifact@v4
      with:
        name: DeerPortal-${{ needs.create-release.outputs.version }}-Linux-packages
        path: |
          build/*.tar.gz
          build/*.deb
          build/*DeerPortal*
        retention-days: 30

    - name: Check for Linux packages
      id: check_linux_files
      run: |
        cd build
        echo "=== Checking for package files ==="
        TGZ_EXISTS="false"
        DEB_EXISTS="false"
        
        if ls *.tar.gz 1> /dev/null 2>&1; then
          echo "TGZ files found:"
          ls -la *.tar.gz
          TGZ_EXISTS="true"
        else
          echo "No TGZ files found"
        fi
        
        if ls *.deb 1> /dev/null 2>&1; then
          echo "DEB files found:"
          ls -la *.deb
          DEB_EXISTS="true"
        else
          echo "No DEB files found"
        fi
        
        echo "tgz_exists=${TGZ_EXISTS}" >> $GITHUB_OUTPUT
        echo "deb_exists=${DEB_EXISTS}" >> $GITHUB_OUTPUT

    - name: Upload Linux TGZ to Release
      if: github.event_name == 'push' && !inputs.test_mode && steps.check_linux_files.outputs.tgz_exists == 'true'
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: build/*.tar.gz
        tag: ${{ github.ref }}
        overwrite: true
        file_glob: true

    - name: Upload Linux DEB to Release
      if: github.event_name == 'push' && !inputs.test_mode && steps.check_linux_files.outputs.deb_exists == 'true'
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: build/*.deb
        tag: ${{ github.ref }}
        overwrite: true
        file_glob: true 